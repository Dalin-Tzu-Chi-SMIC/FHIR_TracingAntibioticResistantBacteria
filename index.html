<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <title>疫調傳播鏈 SMART App (FHIR Sandbox)</title>

    <!-- SMART on FHIR JS 客戶端 -->
    <script src="https://cdn.jsdelivr.net/npm/fhirclient/build/fhir-client.js"></script>

    <!-- Cytoscape.js：用來畫關係圖 -->
    <script src="https://unpkg.com/cytoscape@3.29.2/dist/cytoscape.min.js"></script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei",
          sans-serif;
        margin: 0;
        padding: 0;
        background: #f5f5f7;
      }

      header {
        background: #003366;
        color: #fff;
        padding: 1rem 1.5rem;
      }

      header h1 {
        margin: 0;
        font-size: 1.4rem;
      }

      header small {
        display: block;
        font-size: 0.8rem;
        opacity: 0.8;
      }

      main {
        padding: 1rem 1.5rem 2rem 1.5rem;
        max-width: 1200px;
        margin: 0 auto;
      }

      .card {
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        padding: 1rem 1.2rem;
        margin-bottom: 1rem;
      }

      .card h2 {
        margin-top: 0;
        font-size: 1.1rem;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 0.3rem;
        margin-bottom: 0.5rem;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem 2rem;
        font-size: 0.9rem;
      }

      .meta-label {
        font-weight: 600;
      }

      #cy {
        width: 100%;
        height: 500px;
        border-radius: 6px;
        border: 1px solid #ddd;
      }

      .stats {
        font-size: 0.85rem;
        color: #555;
        margin-bottom: 0.5rem;
      }

      button {
        padding: 0.35rem 0.8rem;
        border-radius: 999px;
        border: none;
        background: #003366;
        color: #fff;
        cursor: pointer;
        font-size: 0.85rem;
      }

      button:hover {
        background: #004a99;
      }

      button:disabled {
        background: #9e9e9e;
        cursor: not-allowed;
      }

      select,
      input[type="text"] {
        padding: 0.25rem 0.4rem;
        border-radius: 999px;
        border: 1px solid #ccc;
        font-size: 0.85rem;
      }

      .error {
        color: #b00020;
        font-weight: 600;
      }

      pre {
        background: #111827;
        color: #e5e7eb;
        padding: 0.7rem;
        border-radius: 6px;
        font-size: 0.8rem;
        overflow: auto;
        max-height: 260px;
      }

      @media (max-width: 768px) {
        main {
          padding: 0.8rem;
        }
        #cy {
          height: 420px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>疫調傳播鏈 SMART App</h1>
      <small>從 FHIR(Observation / Encounter) 組出「病人 → 病人」傳播鏈（透過指定菌株）</small>
    </header>

    <main>
      <!-- FHIR 連線資訊 -->
      <section class="card">
        <h2>FHIR 連線資訊</h2>
        <div id="meta-content" class="meta-row">
          <span>初始化中...</span>
        </div>
      </section>

      <!-- 傳播鏈圖 -->
      <section class="card">
        <h2>傳播鏈關係圖（病人 → 病人，附菌株與病房）</h2>

        <div class="stats" id="graph-stats">尚未載入 FHIR 資料</div>

        <div
          style="
            margin-bottom: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
          "
        >
          <label for="sel-organism" style="font-size: 0.85rem;">選擇抗藥菌株：</label>
          <select id="sel-organism">
            <option value="ALL">全部菌種（不過濾）</option>
            <option value="CRAB">Acinetobacter baumannii(CRAB)</option>
            <option value="E_COLI_CR">E.coli (CR)</option>
            <option value="VRE">Enterococcus faecium(VRE)</option>
            <option value="KP_CR">Klebsiella pneumoniae (CR)</option>
            <option value="CRPA">Pseudomonas aeruginosa(CRPA)</option>
            <option value="MRSA">Staphylococcus aureus(MRSA)</option>
          </select>

          <label for="txt-patient-filter" style="font-size: 0.85rem;">僅保留包含此 Patient ID 的節點（可空白）：</label>
          <input id="txt-patient-filter" type="text" placeholder="例如 130206" />

          <button id="btn-reload-graph">重新從 FHIR 重建傳播鏈圖</button>
          <span style="font-size: 0.8rem; color: #555;">
            邏輯：依「病房 + 菌種」分群；按檢出時間排序，較早病人 → 較晚病人，邊上標示菌名與病房。（目前最多抓前 50 筆 Observation）
          </span>
        </div>

        <div id="cy"></div>
      </section>

      <!-- 除錯 / JSON -->
      <section class="card">
        <h2>除錯訊息 / 原始 JSON</h2>
        <button id="btn-clear-debug">清除訊息</button>
        <pre id="debug-log">// 這裡會顯示 client 狀態、錯誤訊息與部分原始 JSON</pre>
      </section>
    </main>

    <script>
      /********** 抗藥菌株選項設定 **********/
      const BACTERIA_OPTIONS = [
        {
          id: "ALL",
          label: "全部菌種（不過濾）",
          keywords: [],
        },
        {
          id: "CRAB",
          label: "Acinetobacter baumannii(CRAB)",
          keywords: ["acinetobacter baumannii", "crab"],
        },
        {
          id: "E_COLI_CR",
          label: "E.coli (CR)",
          keywords: ["e.coli", "escherichia coli", "cr e.coli", "e coli (cr)"],
        },
        {
          id: "VRE",
          label: "Enterococcus faecium(VRE)",
          keywords: ["enterococcus faecium", "vre"],
        },
        {
          id: "KP_CR",
          label: "Klebsiella pneumoniae (CR)",
          keywords: ["klebsiella pneumoniae", "cr kp", "cr klebsiella"],
        },
        {
          id: "CRPA",
          label: "Pseudomonas aeruginosa(CRPA)",
          keywords: ["pseudomonas aeruginosa", "crpa"],
        },
        {
          id: "MRSA",
          label: "Staphylococcus aureus(MRSA)",
          keywords: ["staphylococcus aureus", "mrsa"],
        },
      ];

      function getSelectedBacteriaOption() {
        const sel = document.getElementById("sel-organism");
        const val = sel.value || "ALL";
        return BACTERIA_OPTIONS.find((x) => x.id === val) || BACTERIA_OPTIONS[0];
      }

      /********** 小工具：Debug Log **********/
      function logDebug(obj, title) {
        const pre = document.getElementById("debug-log");
        const now = new Date().toISOString();
        let text = pre.textContent || "";
        text += `\n\n[${now}] ${title || "訊息"}\n`;
        try {
          text += typeof obj === "string" ? obj : JSON.stringify(obj, null, 2);
        } catch {
          text += String(obj);
        }
        pre.textContent = text;
      }

      /********** 小工具：Mask 病人姓名 **********/
      function maskName(name) {
        if (!name) return "";
        const s = name.trim();
        if (s.length === 1) return s + "○";
        if (s.length === 2) return s[0] + "○";
        return s[0] + "○" + s.slice(2);
      }

      /********** 小工具：短 ID **********/
      function shortId(id) {
        if (!id) return "";
        const s = String(id);
        if (s.length <= 4) return s;
        return s.slice(0, 2) + "…" + s.slice(-2);
      }

      /********** 從 Observation 判斷是否 MDRO，並回傳對應菌種選項 **********/
      function detectMdroFromObservation(obs) {
        if (!obs || !obs.code) return null;

        const code = obs.code || {};
        const coding0 = (code.coding && code.coding[0]) || {};
        const text =
          (code.text || "") +
          " " +
          (coding0.display || "") +
          " " +
          (coding0.code || "");
        const hay = text.toLowerCase();

        for (const opt of BACTERIA_OPTIONS) {
          if (opt.id === "ALL") continue;
          if (opt.keywords.some((k) => hay.includes(k))) {
            return {
              option: opt,
              organismLabel: code.text || coding0.display || coding0.code || opt.label,
            };
          }
        }
        return null;
      }

      /********** 畫 FHIR 連線資訊 **********/
      function renderMeta(client) {
        const div = document.getElementById("meta-content");
        const st = client.state || {};
        const url = st.serverUrl || "(未知)";
        const token = st.tokenResponse || {};
        const patientId = st.patientId || (client.patient && client.patient.id);

        div.innerHTML = `
          <div>
            <span class="meta-label">FHIR Server：</span>
            <span>${url}</span>
          </div>
          <div>
            <span class="meta-label">Access Token：</span>
            <span>${token.access_token ? "已取得" : "尚未取得 / 不需 token"}</span>
          </div>
          <div>
            <span class="meta-label">Patient Id (context)：</span>
            <span>${patientId || "(無病人 context 或為 system/user app)"}</span>
          </div>
          <div>
            <span class="meta-label">Scope：</span>
            <span>${st.tokenResponse?.scope || "(未知)"}</span>
          </div>
        `;
      }

      /********** 從 FHIR 建立「MDRO 個案」清單 **********/
      async function buildTransmissionData(client, bacteriaOption, patientFilterId) {
        // 這裡直接用多病人查詢（實務上可改成院內授權的 system-level 查詢）
        const bundle = await client.request(
          "Observation?category=laboratory&_count=50&_include=Observation:subject&_include=Observation:encounter&_include:iterate=Encounter:location",
          { flat: false }
        );
        logDebug(bundle, "Observation Bundle（多病人模式，_count=50, laboratory）");

        const entries = bundle.entry || [];
        const patientsById = {};
        const encountersById = {};
        const observations = [];

        for (const e of entries) {
          const res = e.resource;
          if (!res || !res.resourceType) continue;
          if (res.resourceType === "Observation") {
            observations.push(res);
          } else if (res.resourceType === "Patient") {
            patientsById[res.id] = res;
          } else if (res.resourceType === "Encounter") {
            encountersById[res.id] = res;
          }
        }

        const cases = [];

        for (const obs of observations) {
          const mdro = detectMdroFromObservation(obs);
          if (!mdro) continue; // 不是我們關心的 MDRO

          // 若有菌種篩選，需比對
          if (bacteriaOption && bacteriaOption.id !== "ALL") {
            if (!mdro || mdro.option.id !== bacteriaOption.id) continue;
          }

          const subjRef = obs.subject && obs.subject.reference;
          if (!subjRef || !subjRef.startsWith("Patient/")) continue;
          const patientId = subjRef.split("/")[1];

          if (patientFilterId) {
            // 若有指定只看某病人相關事件，則要求「邊中至少一端是此病人」
            // 這裡先保留全部個案，之後建圖再過濾
          }

          const patientRes = patientsById[patientId];
          let patientName = "";
          if (patientRes && Array.isArray(patientRes.name) && patientRes.name[0]) {
            const n = patientRes.name[0];
            const full =
              n.text ||
              `${n.family || ""}${(n.given || []).join("")}`.trim();
            patientName = full || "";
          }

          // Encounter / 病房
          const encRef = obs.encounter && obs.encounter.reference;
          let enc = null;
          let wardName = "";
          if (encRef && encRef.startsWith("Encounter/")) {
            const encId = encRef.split("/")[1];
            enc = encountersById[encId];
          }
          if (enc) {
            wardName =
              (enc.location &&
                enc.location[0] &&
                enc.location[0].location &&
                enc.location[0].location.display) ||
              (enc.serviceProvider && enc.serviceProvider.display) ||
              "";
          }

          // 檢驗時間
          const effective =
            obs.effectiveDateTime ||
            (obs.effectivePeriod && obs.effectivePeriod.start) ||
            obs.issued ||
            "";
          const dateKey = effective ? String(effective).slice(0, 10) : "未知日期";
          const effectiveDt = effective ? new Date(effective) : null;

          cases.push({
            obsId: obs.id,
            patientId,
            patientName,
            wardName: wardName || "未知病房",
            organismId: mdro.option.id,
            organismLabel: mdro.organismLabel,
            effective: effectiveDt,
            dateKey,
          });
        }

        logDebug(
          {
            caseCount: cases.length,
            patientCount: Object.keys(patientsById).length,
            bacteria: bacteriaOption ? bacteriaOption.label : "ALL",
          },
          "初步病例 Case 數統計（依菌株過濾後，尚未建圖）"
        );

        return { cases, patientsById };
      }

      /********** 從 cases 建出「病人節點 + 病人→病人」 **********/
      function buildGraphElementsFromCases(cases, patientsById, patientFilterId) {
        if (!cases.length) {
          return {
            elements: [],
            patientCount: 0,
            edgeCount: 0,
          };
        }

        // 先計算每個病人「全體 MDRO 中的最早檢出時間」
        const patientEarliest = {};
        for (const c of cases) {
          if (!c.effective) continue;
          if (!patientEarliest[c.patientId] || c.effective < patientEarliest[c.patientId]) {
            patientEarliest[c.patientId] = c.effective;
          }
        }

        // 分群：groupKey = wardName + '|' + organismId
        const groupMap = {};
        for (const c of cases) {
          const gKey = `${c.wardName}||${c.organismId}`;
          if (!groupMap[gKey]) groupMap[gKey] = [];
          groupMap[gKey].push(c);
        }

        // 病人節點暫存
        const patientNodeMap = {};
        const edges = [];
        const edgeKeySet = new Set();

        // 全域排序，決定 No.1, No.2...
        const allPatientIds = Object.keys(patientEarliest);
        allPatientIds.sort((a, b) => {
          const da = patientEarliest[a];
          const db = patientEarliest[b];
          if (da && db && da.getTime() !== db.getTime()) {
            return da - db;
          }
          return a.localeCompare(b);
        });

        const patientNoMap = {};
        allPatientIds.forEach((pid, idx) => {
          patientNoMap[pid] = idx + 1;
        });

        // 建立節點
        for (const pid of allPatientIds) {
          const pRes = patientsById[pid];
          let nameFull = "";
          if (pRes && Array.isArray(pRes.name) && pRes.name[0]) {
            const n = pRes.name[0];
            const full =
              n.text ||
              `${n.family || ""}${(n.given || []).join("")}`.trim();
            nameFull = full || "";
          }

          const label =
            `No.${patientNoMap[pid]} ` +
            (maskName(nameFull) || shortId(pid) || "未知病人");

          patientNodeMap[pid] = {
            id: "p-" + pid,
            label,
            earliest: patientEarliest[pid],
          };
        }

        // 每一個 group 裡面，照時間排序後連線
        for (const [gKey, groupCases] of Object.entries(groupMap)) {
          if (!groupCases.length) continue;

          // 解析 groupKey
          const [wardName, organismId] = gKey.split("||");
          const organismOption =
            BACTERIA_OPTIONS.find((x) => x.id === organismId) || null;

          // 對 group 內的個案照 effective 時間排序
          const sorted = groupCases
            .filter((c) => !!c.effective)
            .slice()
            .sort((a, b) => a.effective - b.effective);

          // 同一 group 中，為了避免同病人多次檢驗太雜亂，只抓「此 group 中該病人的最早檢驗時間」
          const groupPatientEarliest = {};
          for (const c of sorted) {
            if (!groupPatientEarliest[c.patientId]) {
              groupPatientEarliest[c.patientId] = c;
            }
          }

          const groupPatients = Object.values(groupPatientEarliest).sort(
            (a, b) => a.effective - b.effective
          );

          for (let i = 0; i < groupPatients.length; i++) {
            for (let j = i + 1; j < groupPatients.length; j++) {
              const src = groupPatients[i];
              const tgt = groupPatients[j];
              if (src.patientId === tgt.patientId) continue;

              const fromId = "p-" + src.patientId;
              const toId = "p-" + tgt.patientId;

              // 若有 patientFilterId，要求邊端至少有一端是該病人
              if (patientFilterId) {
                if (
                  src.patientId !== patientFilterId &&
                  tgt.patientId !== patientFilterId
                ) {
                  continue;
                }
              }

              const ek = `${fromId}|${toId}|${organismId}`;
              if (edgeKeySet.has(ek)) continue;
              edgeKeySet.add(ek);

              const label =
                (organismOption ? organismOption.label : organismId) +
                " / " +
                wardName;

              edges.push({
                data: {
                  id: "e-" + ek.replace(/\|/g, "_"),
                  source: fromId,
                  target: toId,
                  type: "pp",
                  label,
                },
              });
            }
          }
        }

        // 若有 patientFilterId，沒有出現在任何邊中，仍然要顯示他的節點
        const elements = [];
        Object.values(patientNodeMap).forEach((p) => {
          if (!patientFilterId || p.id === "p-" + patientFilterId) {
            elements.push({
              data: {
                id: p.id,
                label: p.label,
                type: "patient",
              },
            });
          } else {
            // 有 filter 的情況下：節點需要至少連到一條邊才畫，避免整張圖只剩一堆孤點
            const hasEdge =
              edges.some((e) => e.data.source === p.id || e.data.target === p.id);
            if (hasEdge) {
              elements.push({
                data: {
                  id: p.id,
                  label: p.label,
                  type: "patient",
                },
              });
            }
          }
        });

        elements.push(...edges);

        const patientCount = elements.filter((el) => el.data.type === "patient").length;
        const edgeCount = edges.length;

        return {
          elements,
          patientCount,
          edgeCount,
        };
      }

      /********** 用 Cytoscape 畫圖 **********/
      function renderGraph(elements, statsText) {
        const statsDiv = document.getElementById("graph-stats");
        statsDiv.textContent = statsText;

        const cy = cytoscape({
          container: document.getElementById("cy"),
          elements: elements,
          style: [
            {
              selector: "node[type = 'patient']",
              style: {
                "background-color": "#f28b82",
                "border-color": "#042433",
                "border-width": 2,
                label: "data(label)",
                "text-valign": "center",
                "text-halign": "center",
                "text-wrap": "wrap",
                "font-size": 10,
                shape: "ellipse",
                width: 40,
                height: 40,
              },
            },
            {
              selector: "edge[type = 'pp']",
              style: {
                "line-style": "solid",
                "line-color": "#7a7a7a",
                "target-arrow-shape": "triangle",
                "target-arrow-color": "#7a7a7a",
                "curve-style": "bezier",
                width: 2,
                label: "data(label)",
                "font-size": 8,
                "text-background-color": "#ffffff",
                "text-background-opacity": 0.7,
                "text-background-padding": 1,
              },
            },
            {
              selector: ":selected",
              style: {
                "border-width": 3,
                "border-color": "#ffab00",
                "line-color": "#ffab00",
                "target-arrow-color": "#ffab00",
              },
            },
            {
              selector: ".dim",
              style: {
                opacity: 0.2,
              },
            },
          ],
          layout: {
            name: "cose",
            animate: false,
          },
        });

        cy.on("tap", "node[type = 'patient']", (evt) => {
          const node = evt.target;
          cy.elements().removeClass("dim");
          const neighborhood = node.closedNeighborhood();
          cy.elements().difference(neighborhood).addClass("dim");
        });

        cy.on("tap", (evt) => {
          if (evt.target === cy) {
            cy.elements().removeClass("dim");
          }
        });
      }

      /********** 初始化整個 App **********/
      FHIR.oauth2
        .ready()
        .then(async (client) => {
          logDebug(client.state, "SMART client.state");
          renderMeta(client);

          const reloadBtn = document.getElementById("btn-reload-graph");
          const clearBtn = document.getElementById("btn-clear-debug");
          const selOrganism = document.getElementById("sel-organism");
          const txtPatientFilter = document.getElementById("txt-patient-filter");

          async function reloadGraph() {
            const opt = getSelectedBacteriaOption();
            const filterId = (txtPatientFilter.value || "").trim();

            reloadBtn.disabled = true;
            document.getElementById("graph-stats").textContent =
              `從 FHIR 讀取資料並重建傳播鏈中...（最多 50 筆 Observation，菌種：${opt.label}${
                filterId ? `，僅顯示與 Patient/${filterId} 相關邊` : ""
              }）`;

            try {
              const { cases, patientsById } = await buildTransmissionData(
                client,
                opt,
                filterId || null
              );
              if (!cases.length) {
                renderGraph(
                  [],
                  `查無符合條件的抗藥菌 Observation（菌種：${opt.label}），無法建立傳播鏈。`
                );
                reloadBtn.disabled = false;
                return;
              }

              const { elements, patientCount, edgeCount } =
                buildGraphElementsFromCases(cases, patientsById, filterId || null);

              const statsText = `節點：病人 ${patientCount} 人；邊：病人 → 病人 ${edgeCount} 條。` +
                `（菌種：${opt.label}，最多 50 筆 Observation${
                  filterId ? `，與 Patient/${filterId} 相關` : ""
                }）`;
              renderGraph(elements, statsText);
            } catch (err) {
              console.error(err);
              logDebug(err, "建立傳播鏈失敗");
              document.getElementById("graph-stats").innerHTML =
                '<span class="error">無法從 FHIR 建立傳播鏈，請查看下方 Debug 訊息。</span>';
              renderGraph([], "建立傳播鏈失敗。");
            } finally {
              reloadBtn.disabled = false;
            }
          }

          // 初次載入
          await reloadGraph();

          reloadBtn.addEventListener("click", reloadGraph);
          clearBtn.addEventListener("click", () => {
            document.getElementById("debug-log").textContent =
              "// 已清除訊息，可重新操作。";
          });
          selOrganism.addEventListener("change", reloadGraph);
          txtPatientFilter.addEventListener("change", reloadGraph);
        })
        .catch((err) => {
          console.error("SMART 初始化失敗", err);
          logDebug(err, "SMART 初始化失敗");
          document.getElementById("meta-content").innerHTML =
            '<span class="error">SMART 初始化失敗，請確認 launch.html 設定與沙盒環境。</span>';
          document.getElementById("graph-stats").textContent =
            "無法載入 FHIR 資料。";
        });
    </script>
  </body>
</html>
